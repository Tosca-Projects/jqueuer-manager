tosca_definitions_version: tosca_simple_yaml_1_0

imports:
  - https://raw.githubusercontent.com/micado-scale/tosca/develop/micado_types.yaml

repositories:
  docker_hub: https://hub.docker.com/

topology_template:
  node_templates:
    jqueuer-rabbit:
      type: tosca.nodes.MiCADO.Container.Application.Docker.Deployment
      properties:
        image: rabbitmq:3.7
        env:
          - name: RABBITMQ_DEFAULT_USER
            value: admin
          - name: RABBITMQ_DEFAULT_PASS
            value: mypass
        ports:
        - port: 5672
      requirements:
      - host: jq-server

    jqueuer-redis:
      type: tosca.nodes.MiCADO.Container.Application.Docker.Deployment
      properties:
        image: redis:alpine3.10
        command:
        - redis-server
        args:
        - --requirepass mypass
        ports:
        - port: 6379
      requirements:
      - host: jq-server

    jqueuer-manager:
      type: tosca.nodes.MiCADO.Container.Application.Docker.Deployment
      properties:
        image: micado/jqueuer-manager:develop
        ports:
        - containerPort: 9081
        - port: 8081
          nodePort: 30888
      requirements:
      - host: jq-server
      - volume: docker-socket-host-vol

    jqueuer-pushgateway:
      type: tosca.nodes.MiCADO.Container.Application.Docker.Deployment
      properties:
        image: prom/pushgateway
        ports:
        - containerPort: 9091
        - port: 9091
      requirements:
      - host: jq-server

    jqueuer-agent:
      type: tosca.nodes.MiCADO.Container.Application.Docker.DaemonSet
      properties:
        image: micado/jqueuer-agent:develop
        env:
        - name: PUSHGATEWAY_SERVICE_NAME
          value: jqueuer-pushgateway
        - name: PUSHGATEWAY_PORT
          value: "9091"
      requirements:
        - host: worker-node
        - volume: docker-binary-host-vol
        - volume: docker-socket-host-vol

    docker-binary-host-vol:
      type: tosca.nodes.MiCADO.Container.Volume.HostPath
      properties:
        path: /usr/bin/docker

    docker-socket-host-vol:
      type: tosca.nodes.MiCADO.Container.Volume.HostPath
      properties:
        path: /var/run/docker.sock
###
### The container image below might need to be changed depending on your experimentation tool
###
    worker:
      type: tosca.nodes.MiCADO.Container.Application.Docker.Deployment
      properties:
        image: osabuoun/repast
        tty: true
      requirements:
        - host: worker-node
###
### The worker node is directly below, change resources if necessary
###
    worker-node:
      type: tosca.nodes.MiCADO.CloudSigma.Compute.Occo.small
      properties:
        vnc_password: secret
        libdrive_id: <INSERT_LIBRARY_DRIVE_ID_HERE>
        public_key_id: <INSERT_PUBLIC_KEY_ID_HERE>
        nics:
        - firewall_policy: <INSERT_FIREWALL_POLICY_ID_HERE>
          ip_v4_conf:
            conf: dhcp

    jq-server:
      type: tosca.nodes.MiCADO.CloudSigma.Compute.Occo.small
      properties:
        vnc_password: secret
        libdrive_id: <INSERT_LIBRARY_DRIVE_ID_HERE>
        public_key_id: <INSERT_PUBLIC_KEY_ID_HERE>
        nics:
        - firewall_policy: <INSERT_FIREWALL_POLICY_ID_HERE>
          ip_v4_conf:
            conf: dhcp
        context:
          append: true
          cloud_config: |
            runcmd:
            - echo never > /sys/kernel/mm/transparent_hugepage/enabled
###
### The policies are below
###
  policies:
    - scalability:
        type: tosca.policies.Scaling.MiCADO
        targets: [ worker-node ]
        properties:
          sources:
          - 'jqueuer-pushgateway:9091'
          - 'jqueuer-manager:9081'
          constants:
            MAXNODES: 10
            MAXCONTAINERS: 10
            EXPERIMENT_ID: exp_123456789_123
          queries:
            AET: "jqueuer_single_task_duration{experiment_id='{{EXPERIMENT_ID}}'}"
            REMAININGTIME: "jqueuer_experiment_deadline{experiment_id='{{EXPERIMENT_ID}}'}-time()"
            FIRSTJOB: "min(jqueuer_job_running_timestamp{experiment_id='{{EXPERIMENT_ID}}'})"
            JOBSRUN: "count(jqueuer_job_running{experiment_id='{{EXPERIMENT_ID}}'} == 1)"
            JOBSFAIL: "count(jqueuer_job_failed{experiment_id='{{EXPERIMENT_ID}}'})"
            TOTALJOBS: "count(jqueuer_job_added{experiment_id='{{EXPERIMENT_ID}}'})"
            ITEMS: "count(jqueuer_job_added{experiment_id='{{EXPERIMENT_ID}}'})-count(jqueuer_task_accomplished{experiment_id='{{EXPERIMENT_ID}}'} == 1)"
            COMPLETED: "count(jqueuer_task_accomplished{experiment_id='{{EXPERIMENT_ID}}'} == 1)"
            CALC_AET: "AVG(jqueuer_task_accomplished_duration{experiment_id='{{EXPERIMENT_ID}}'})"
          min_instances: 0
          max_instances: "{{MAXNODES}}"
          scaling_rule: |
            if not JOBSFAIL:
              JOBSFAIL = 0
            reqnodes=0
            if COMPLETED and not ITEMS:
              ITEMS = TOTALJOBS - COMPLETED
            if COMPLETED>4:
              AET = CALC_AET
            if not COMPLETED:
              ITEMS = TOTALJOBS
            if ITEMS-JOBSFAIL>0:
              calculation = ceil(AET/((REMAININGTIME-AET*0.20)/ITEMS))
              if calculation <= 0:
                calculation = ITEMS
              reqconts = min([MAXCONTAINERS, calculation])
              reqnodes = ceil(reqconts)
              if reqnodes>m_node_count and JOBSRUN<ITEMS:
                m_node_count = min([reqnodes, MAXNODES])
              if REMAININGTIME>AET:
                if reqnodes<m_node_count-1 and m_time_since_node_count_changed>60:
                  m_node_count = max([0, reqnodes])
            else:
              m_node_count = 0
            print "Number of required nodes:",reqnodes
            print "Number of requested nodes:",m_node_count

    - scalability:
        type: tosca.policies.Scaling.MiCADO
        targets: [ worker ]
        properties:
          min_instances: 0
          max_instances: "{{MAXCONTAINERS}}"
          scaling_rule: |
            if not JOBSFAIL:
              JOBSFAIL = 0
            if COMPLETED and not ITEMS:
              ITEMS = TOTALJOBS - COMPLETED
            if COMPLETED>4:
              AET = CALC_AET
            if not COMPLETED:
              ITEMS = TOTALJOBS
            print "AET:",AET
            print "Remaining time:", REMAININGTIME
            print "Length of queue:", ITEMS
            print "Failed jobs:", JOBSFAIL
            required_count = 0
            if ITEMS-JOBSFAIL>0:
              calculation = ceil(AET/((REMAININGTIME-AET*0.20)/ITEMS))
              if calculation <= 0:
                calculation = ITEMS
              required_count = min([MAXCONTAINERS, calculation])
              if REMAININGTIME>AET:
                if required_count<m_container_count-1:
                  m_container_count = min([required_count, len(m_nodes) * 1])
              if required_count>m_container_count and JOBSRUN<ITEMS:
                m_container_count = min([required_count, len(m_nodes) * 1])
            else:
              m_container_count = 0
            print "Number of required containers:",required_count
            print "Number of requested containers:",m_container_count
